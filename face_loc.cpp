/**
* Locate face and save the extracted face(*.jpg) to ./detected_face/
* Using .txt file generated by dataset.py and save corresponding txt
* in ./face_detection/.
* See README.md for details.
*/

#include "opencv2/opencv.hpp"
#include "FaceLocationInterface.h"
#include <fstream>
#include <string>

#include "glog/logging.h"


using std::string;

/**
* @brief Return dirpath and basename of a path.
*/
int splitFilename(const string& str, string& dir, string& base) {
	std::size_t found = str.find_last_of("/\\");
	if (found != string::npos) {
		dir = str.substr(0, found);
		base = str.substr(found + 1);
		return 0;
	}
	else {
		return -1;
	}

}

int face_loc() {
	
	// google::InitGoogleLogging("FaceLocationGlog");
	// LOG(INFO) << "Initialize Face location lib.";
	// int InitializeFaceLib(double dConfidence, int nDevType=0, int nProcessIdx=0)
	// dConfidence: confidence
	// nDevType: GPU Server
	// nProcessIdx: assign GPU according to PID ??
	printf("Initialize face location lib.\n");
	InitializeFaceLib(0.3, 2, 0);
	// txt file, save img path and location coordination
	string sFilePath = ".\\dataset\\img_list.txt";  
	string sLocFilePath = ".\\face_detection\\vs_loc_list.txt";
	string sLocImgFilePath = ".\\face_detection\\vs_img_list.txt";
	
	string strPath = "";
	string dirName = "";
	string baseName = "";
	string newImgPath = "";

	std::fstream fImg(sFilePath.c_str(), std::ios::in);
	std::fstream fFaceLoc(sLocFilePath.c_str(), std::ios::out);
	std::fstream fFaceLocImg(sLocImgFilePath.c_str(), std::ios::out);
	VEC_FACERECTINFO vecRlt;

	cv::Mat srcMat;
	IplImage qImg;

	// location information
	int x, y, width, height;
	cv::Rect faceRect;
	if (fImg.good()) {
		while (std::getline(fImg, strPath)) {
			// readin img
			srcMat = cv::imread(strPath);
			
			if (!srcMat.data)
				continue;
			// get img path
			splitFilename(strPath, dirName, baseName);
			// location
			qImg = IplImage(srcMat);
			LocationFace((unsigned char*)qImg.imageData, qImg.width, qImg.height, EImgType_Rgb24, 1, vecRlt);
			printf("%d faces found in image %s\n", vecRlt.size(), strPath.c_str());
			for (int n = 0; n<vecRlt.size(); n++) {
				SFaceRectInfo sInfo = vecRlt[n];
				x = sInfo.nX;
				y = sInfo.nY;
				width = sInfo.nWidth;
				height = sInfo.nHeight;

				//make it boarder
				double tmp_x = (double)x;
				double tmp_y = (double)y;
				double tmp_width = (double)width;
				double tmp_height = (double)height;
				tmp_x = tmp_x - tmp_height / 6;
				tmp_y = tmp_y - tmp_width / 6;
				tmp_height = tmp_height * (1 + 1.0 / 3);
				tmp_width = tmp_width * (1 + 1.0 / 3);

				x = (int)tmp_x;
				y = (int)tmp_y;
				tmp_height = (int)tmp_height;
				tmp_width = (int)tmp_width;

				// Use opencv to save image in the location rectangle.
				faceRect = cv::Rect(x, y, width, height);
				cv::Mat locatedFace;
				srcMat(faceRect).copyTo(locatedFace);
				newImgPath = dirName + string("//") + string("vs_detected_") + baseName;
				cv::imwrite(newImgPath,
							locatedFace);

				fFaceLoc << std::to_string(x) + string(" ")\
					<< std::to_string(y) + string(" ")\
					<< std::to_string(width) + string(" ")\
					<< std::to_string(height) + string(" ")\
					<< std::endl;
				fFaceLocImg << newImgPath << std::endl;
			}
		}
	}
	ReleaseFaceLib();
}